// 64 битный формат IEEE-754 «числа с плавающей точкой двойной точности».
// Для хранения числа используется 64 бита: 52 из них используется для хранения цифр,
// 11 из них для хранения положения десятичной точки (если число целое, то хранится 0),
// и один бит отведён на хранение знака.
console.log(1e500); // Infinity, т.к. число слошком больше и переполнило выделенную память
// -2 ** 53 < BigInt < 2 ** 53

let billion = 1e9; // 1000000000
let ms = 1e-6; // 0.000001

// 16-еричная запись. 0х - обозначается шеснадцатеричную запись, далее идет число.
console.log(0xff); // 255. Регистр не имеет значения

// 2-ичные. 0b
let a = 0b11111111; // 255

// 8-еричные. 0o
let b = 0o377; // 255

console.log(a === b); // true
console.log(0xff === 255); // true

// ----------------------------------------------

// toString(base) , где base (default = 10) 2...36
// base = 36 , используется весь латинский алфавит для представления числа (0...9, A...Z).
let num = 255;
console.log(num.toString()); // 255
console.log(a.toString()); // 255
console.log(a.toString(2)); // 11111111

// для создания короткой ссылки
// 2 ТОЧКИ! - вызов метода непосредственно на числе.
// Т.К. после первой точки предполагается десятичная часть!
console.log(123456789..toString(36)); // 21i3v9
console.log((123456789).toString(36)); // 21i3v9. То же самое

// ----------------------------------------------

// Округления
Math.floor(3.1); // 3 - в меньшую сторону
Math.floor(-1.1); // -2 - в меньшую сторону

Math.ceil(3.1); // 4 - в большую сторону
Math.ceil(-1.1); // -1 - в большую сторону

Math.round(3.1); // 3 - до ближайшего целого
Math.round(-1.1); // -1 - до ближайшего целого

// Math.trunc не поддерживается IE
Math.trunc(3.1); // 3 - откидывает дробную часть без округления
Math.trunc(-1.1); // -1 - откидывает дробную часть без округления

// Есть 2 пути округления:
let number = 1.23456;
console.log(Math.floor(number * 100) / 100); // 1.23456 -> 123.456 -> 123 -> 1.23
// результат toFixed - строка!!! Это гарантирует, что результат будет с необходимым
// количеством чисел после запятой!!!
console.log(number.toFixed(2)); // '1.23'
console.log(+number.toFixed(2)); // 1.23
console.log(number.toFixed(10)); // получить 10 чисел после запятой

// ----------------------------------------------

// ПОТЕРЯ ТОЧНОСТИ!!!
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004
// Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей.
// Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления,
// на самом деле являются бесконечной дробью в двоичной форме.
//
// Другими словами, что такое 0.1? Это единица делённая на десять — 1/10, одна десятая.
// В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: 1/3,
// которая становится бесконечной дробью 0.33333(3).
//
// Деление на 10 гарантированно хорошо работает в десятичной системе, но деление на 3 – нет.
// По той же причине и в двоичной системе счисления, деление на 2 обязательно сработает,
// а 1/10 становится бесконечной дробью.

console.log(0.1.toFixed(20)); // 0.10000000000000000555
// Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа.
// Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности»,
// но она существует.

// Для решения проблемы лучше использовать метод toFixed;
console.log((0.1+0.2).toFixed(2)); // "0.30"
console.log(+(0.1+0.2).toFixed(2)); // 0.3

// Метод умножения/деления уменьшает погрешность, но полностью её не решает.
console.log( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
console.log( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001

console.log(9999999999999999); // 10000000000000000
// Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают
// до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак.
// Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.
//
// Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число»,
// что мы и видим в примере выше. Как говорится: «как смог, так записал».
console.log(-0 === 0); // true, но некоторые методы различают отриц и полож нули.

// ----------------------------------------------

// isFinite и isNaN
// Infinity (-Infinity) - особенное целочисленное знач.
// NaN - ошибка, при применении численных операторов к нечисленным значениям. Оно уникально
console.log(isNaN(NaN)); // true
console.log(isNaN('str')); // true
console.log(isNaN(24)); // false
console.log(NaN === NaN); // false - число NaN не равно само себе

console.log(isFinite('15')); // true - приводит к числу!
console.log(isFinite('str')); // false, потому что спец. знач NaN
console.log(isFinite(NaN)); // false, потому что спец. знач NaN
console.log(isFinite('')); // true, т.к. пустая строка интерпретируется как число 0
console.log(isFinite(15)); // true
console.log(isFinite(Infinity)); // false

// Используется для случаев, когда нужно проверить число ли введено.
let promptNum = +prompt('enter a number', '');
alert(isFinite(promptNum)); // true, кроме ситуаций, когда аргумент Infinity/-Infinity или NaN

// Object.is(a1, a2) - сравнение 2 значений, как и ===, НО!
console.log(Object.is(NaN, NaN)); // true
console.log(Object.is(0, -0)); // false. Т.к. технически 0 и -0 это разные значения.

// ----------------------------------------------

console.log(Number('') === Number('0')); // true, т.к. пустая строка интерпретируется как число 0
console.log(+'' === +'0'); // true. То же самое
console.log(+'100px'); // NaN

// parseInt(str, radix) и parseFloat - достать число из строки, но это число должно быть вначале!
// при нахождении буквы или символа (кроме первой точки для parseFloat) прерывает преобразование
// Возвращают NaN если не смогли прочесть ни одну цифру
// radix - система счисления.

console.log(parseInt('100px')); // 100
console.log(parseFloat('12.5rem')); // 12.5
console.log(parseFloat('11dsdf12.5rem')); // 11
console.log(parseInt('dsdf12.5rem')); // NaN
console.log(parseInt('ff')); // NaN
console.log(parseInt('0xff', 16)); // 255
console.log(parseInt('ff', 16)); // 255 - можно без 0x

// ----------------------------------------------

Math.random() // возвращает псевдослучайное число в диапазон от 0 (включительно) до 1 (не включая)
Math.max(1, 3, 4); // 4 - возвращает наибольшее из чисел
Math.min(1, 3, 4); // 1 - возвращает наименьшее из чисел
Math.pow(2, 10); // 2 в степени 10

// ----------------------------------------------

let task1a = +prompt('a', 0);
let task1b = +prompt('b', 0);
alert(task1a + task1b);

console.log(1.35.toFixed(2)); // 1.4
console.log(6.35.toFixed(2)); // 6.3 - т.к. 6.35 в двоичной системе - бесконечная дробь
console.log(6.35.toFixed(20)); // 6.34999999999999964473

// Для исправления ошибки округления:
console.log((6.35 * 10).toFixed(20)); // 63.50000000000000000000 - не теряется точность
// для 0.5, т.к. это 1/2. Дробные числа деленные на степень 2 точно представлены в двоичной системе
console.log(Math.round(6.35 * 10)/10); // 6.4

function readNumber() {
    let value
    do {
        value = prompt('Введите число!');
        if (value === null || value === '') return null;
    } while (isFinite(value) !== true)
    return +value;
}
console.log(readNumber());

// БЕСКОНЕЧНЫЙ ЦИКЛ, Т.К. ПРИБАВЛЕНИЕ ДРОБЕЙ СКЛАДЫВАЕТ И ПОТЕРИ НЕТОЧНОСТИ,
// ЗНАЧЕНИЕ НИКОГДА НЕ БУДЕТ РАВНО 10
// let i = 0;
// while (i !== 10) {
//     i += 0.2;
// }
// ВЫВОД: ИЗБЕГАТЬ ПРОВЕРОК НА РАВЕНСТВО ПРИ РАБОТЕ С ДЕСЯТИЧНЫМИ ДРОБЯМИ

// случайное число от мин до макс (не включая макс)
function random(min, max) {
    return (Math.random() * (max - min)) + min;
}
console.log(random(99,100));

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// случайное целое число от мин до макс (включительно):
// НЕПРАВИЛЬНОЕ РЕШЕНИЕ! Вероятность получения min и max в 2 раза ниже!
// function randomInteger(min, max) {
//   let rand = min + Math.random() * (max - min);
//   return Math.round(rand);
// }
// Т.К.:
// число от 1    ... до 1.4999999999  округлится до 1
// число от 1.5  ... до 2.4999999999  округлится до 2
// число от 2.5  ... до 2.9999999999  округлится до 3
// !!!!! Т.Е. 1 И 3 БУДУТ ПОПАДАТЬСЯ В 2 РАЗА РЕЖЕ !!!!!
// ПРАВИЛЬНОЕ РЕШЕНИЕ:
function randomInteger(min, max) {
    return Math.floor((Math.random() * (max + 1 - min)) + min);
}
// ЛИБО
function randomInteger2(min, max) {
    return Math.round(min - 0.5 + Math.random() * (max + 1 - min));
}
