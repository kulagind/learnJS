// obj1 + obj1 или alert(obj) - сначала преобразуются в примитивы

// - В логическом контексте все объекты == true
// - При вычитании и др. математических операциях преобразуются в числа
// (например объекты Date)
// - При выводе на экран (alert) чаще преобразуются в строки

// Мы можем тонко настраивать строковые и численные преобразования,
// используя специальные методы объекта.
// Существуют три варианта преобразований («три хинта»), описанные в спецификации:

let obj = {}, anotherObj = {};

// 1) string
alert(obj); // вывод
anotherObj[obj] = 123; // использование объекта в качестве имени свойства

// 2) number
// математическое (исключая бинарный оператор "+")
let num = Number(obj); // явное преобразование
let n = +obj; // унарный плюс
let delta = obj - anotherObj;
let greater = obj > anotherObj; // для сравнений больше/меньше

// 3) default
// Происходит редко, когда оператор «не уверен», какой тип ожидать.
let total = obj + anotherObj; // бинарный плюс
if (obj == 1) {} // obj == string/number/symbol
// Оператор больше/меньше <> также может работать как со строками,
// так и с числами. Однако, по историческим причинам он использует
// хинт «number», а не «default».

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// На практике все встроенные объекты, исключая Date
// реализуют "default" преобразования тем же способом,
// что и "number". И нам следует поступать также.
// И если мы считаем "default" и "number" одинаковыми, как большинство
// встроенных объектов, то остаются всего два варианта преобразований, Карл!!!

// --------------------------------------------------------

// В процессе преобразования движок JavaScript пытается найти и вызвать
// три следующих метода объекта:
// 1) Вызывает obj[Symbol.toPrimitive](hint) – метод с символьным ключом
// Symbol.toPrimitive (системный символ), если такой метод существует,
// и передаёт ему хинт.
// 2) Иначе, если хинт равен "string"
// пытается вызвать obj.toString(), а если его нет, то obj.valueOf(),
// если он существует.
// 3) В случае, если хинт равен "number" или "default"
// пытается вызвать obj.valueOf(), а если его нет, то obj.toString(),
// если он существует.

// --------------------------------------------------------

// Symbol.toPrimitive - метод с таким названием исп. для всех преобразований
// obj[Symbol.toPrimitive] = function(hint) {
    // должен вернуть примитивное значение
    // hint равно чему-то одному из: "string", "number" или "default"
// };

let user = {
    name: "John",
    money: 1000,

    [Symbol.toPrimitive](hint) {
        console.log(`hint: ${hint}`);
        return hint === "string" ? `name is ${this.name}` : this.money;
    }
};
alert(user); // hint: string -> name is John
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500

// Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти
// toString и valueOf и вызвать их следующим образом:
//
// toString -> valueOf для хинта со значением «string».
// valueOf -> toString – в ином случае.

let user2 = {
    name: "John",
    money: 1000,

    // для хинта равного "string"
    toString() {
        return `name is ${this.name}`;
    },

    // для хинта равного "number" или "default"
    valueOf() {
        return this.money;
    }
};
alert(user2); // toString -> name is John
alert(+user2); // valueOf -> 1000
alert(user2 + 500); // valueOf -> 1500

// В отсутствие Symbol.toPrimitive и valueOf,
// toString обработает все случаи преобразований к примитивам.
let user3 = {
    name: "John",

    toString() {
        return this.name;
    }
};
alert(user3); // toString -> John
alert(user3 + 500); // toString -> John500

// Нет обязательного требования, чтобы toString() возвращал именно строку,
// или чтобы метод Symbol.toPrimitive возвращал именно число для хинта
// «number».
// Единственное обязательное требование: методы должны возвращать примитив,
// а не объект.
