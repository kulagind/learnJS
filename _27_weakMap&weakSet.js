let john = { name: "John" };
let map = new Map();
map.set(john, "...");
john = null; // перезаписываем ссылку на объект
// объект john сохранён внутри объекта `Map`,
// он доступен через map.keys()

// WeakMap – принципиально другая структура в этом аспекте.
// Она не предотвращает удаление объектов сборщиком мусора, когда эти объекты
// выступают в качестве ключей.
let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "ok"); // работает (объект в качестве ключа)
// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект

let john2 = { name: "John" };
let weakMap2 = new WeakMap();
weakMap2.set(john2, "...");
john2 = null; // перезаписываем ссылку на объект
// объект john2 удалён из памяти!
// Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на
// этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.

// НЕ ПОДДЕРЖИВАЕТ ПЕРЕБОР И МЕТОДЫ keys(), values(), entries() - т.к. неизвестно,
// когда будет "сборка мусора" и удаленный объект будет удален на самом деле. Так
// что технически количество объектов коллекции WeakMap неизвестно

// В WeakMap присутствуют только следующие методы:
// weakMap.get(key)
// weakMap.set(key, value)
// weakMap.delete(key)
// weakMap.has(key)

// В основном, WeakMap используется в качестве дополнительного хранилища данных.

// Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже
// сторонней библиотеке, и хотим сохранить у себя какие-то данные для него,
// которые должны существовать лишь пока существует этот объект, то WeakMap –
// как раз то, что нужно.
//
// Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора
// удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.

weakMap.set(john, "секретные документы");
// если john умрёт, "секретные документы" будут автоматически уничтожены

// Счетчик посещений, при покидании пользователя (удаляется сборщиком) нет смысла хранить счетчик
let visitsCountMap = new Map();
function countUser(user) {
    let count = visitsCountMap.get(user) || 0;
    visitsCountMap.set(user, count + 1);
}
let john3 = { name: "John3" };
countUser(john3); //ведём подсчёт посещений
// пользователь покинул нас
john = null;
// Нам нужно очищать visitsCountMap при удалении объекта пользователя,
// иначе коллекция будет бесконечно расти. Подобная очистка может быть неудобна в
// реализации при сложной архитектуре приложения.

let visitsCountMap2 = new WeakMap(); // map: пользователь => число визитов
// Нет необходимости очищать WeakMap вручную
// увеличиваем счётчик
function countUser2(user) {
    let count = visitsCountMap.get(user) || 0;
    visitsCountMap.set(user, count + 1);
}

// Другая частая сфера применения – это кеширование, когда результат вызова функции
// должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы
// на том же объекте могли просто брать уже готовый результат, повторно используя его.

let cache = new WeakMap();
function process(obj) {
    if (!cache.has(obj)) {
        let result = /* вычисляем результат для объекта */ obj;
        cache.set(obj, result);
    }
    return cache.get(obj);
}

let obj = {}; // какой-то объект

let result1 = process(obj);
let result2 = process(obj);

obj = null;
// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются


// ---------------------------------------------
// WeakSet
// - Она аналогична Set, но мы можем добавлять в WeakSet только объекты
// (не примитивные значения).
// - Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
// - Как и Set, она поддерживает add, has и delete, но не size, keys() и
// не является перебираемой.

// Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве
// дополнительного хранилища. Но не для произвольных данных, а скорее для значений
// типа «да/нет».

// Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт:
let visitedSet = new WeakSet();
let johnathan = {name: 'Johnathan'};
let dima = {name: 'Dima'};
let penya = {name: 'Penya'};
visited.add(johnathan); // заходил джон
visited.add(dima); // потом дима
visited.add(johnathan); // потом снова джон
// проверим, заходил ли John?
console.log(visitedSet.has(johnathan)); // true
// проверим, заходила ли Penya?
console.log(visitedSet.has(penya)); // false
johnathan = null;
// структура данных visitedSet будет очищена автоматически

// Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя
// перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает
// WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем
// данных для объектов, управляемых из каких-то других мест в коде.

// --------------------------------------------
