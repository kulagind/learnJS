// Рекурсия - прием программирования, полезный в ситуациях когда задача может быть естественно
// разделена на несколько аналогичных, но более простых задач.
// Суть рекурсии в том, что задача вызывает сама себя!

// Когда функция производит вложенный вызов, происходит следующее:
// 1) Выполнение текущей функции приостанавливается.
// 2) Контекст выполнения, связанный с ней, запоминается в специальной структуре данных –
// стеке контекстов выполнения.
// 3) Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
// 4) После их завершения старый контекст достаётся из стека, и выполнение внешней функции
// возобновляется с того места, где она была остановлена.

// Каждый рекурсивный вызов добавляется в стек со своим контекстом.
// Затем после расчета вычисление начинается начинается по стеку с конца к первому вызову.

// 1 итеративный способ мышления (цикл for):
function pow(x, n) {
    let result = 1;
    // умножаем result на x n раз в цикле
    for (let i = 0; i < n; i++) {
        result *= x;
    }
    return result;
}
console.log(pow(2, 3)); // 8

// Реализация возведения в степень через цикл гораздо более экономна

// 2 рекурсивный способ:
function pow2(x, n) {
    return n == 1 ? x : x * pow2(x, n - 1);
}
console.log(pow2(2, 3)); // 8

// Глубина рекурсии - количество вложенных вызовов. Максимальная глубина рекурсии ограничена
// движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов

// Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).
//
// Контекст выполнения – специальная внутренняя структура данных, которая содержит
// информацию о вызове функции. Она включает в себя конкретное место в коде, на котором
// находится интерпретатор, локальные переменные функции, значение this (мы не используем
// его в данном примере) и прочую служебную информацию.

// Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для
// неоконченных внешних вызовов в стеке, и в данном случае это приводит к тому, что
// возведение в степень n хранит в памяти n различных контекстов.

// Рекурсия часто используется для перебора полной вложенности объекта

// Связанный список - структура данных на подобии массива, но с быстрой вставной/удалением.
// Главный недостаток - невлзможность получшения элемента по индексу.
// Элемент связанного списка определяется рекурсивно как объект с:
// value,
// next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.
let list = {
    value: 1,
    next: {
        value: 2,
        next: {
            value: 3,
            next: {
                value: 4,
                next: null
            }
        }
    }
};
// добавление нового элемента в список:
list = { value: "new item", next: list };
// удаление элемента:
list.next = list.next.next;

// Списки могут быть улучшены:
// - Можно добавить свойство prev в дополнение к next для ссылки на предыдущий элемент,
// чтобы легко двигаться по списку назад.
// - Можно также добавить переменную tail, которая будет ссылаться на последний элемент списка
// (и обновлять её при добавлении/удалении элементов с конца).
// - …Возможны другие изменения: главное, чтобы структура данных соответствовала нашим
// задачам с точки зрения производительности и удобства.

// Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется
// для оптимизации работы. Но для многих задач рекурсивное решение достаточно быстрое и
// простое в написании и поддержке.

// ------------------------------------------------

function sumToRecursion(n) {
    return n === 1 ? n : n + sumToRecursion(n-1);
}
function sumToIteration(n) {
    let sum = 0;
    for (let i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
function sumToArifmeticProgression(n) {
    return n * (n + 1) / 2;
}
// console.log(sumToRecursion(100000)); Ошибка!!! переполнение стека вызовов!
console.log(sumToRecursion(100)); // Самый медленный, т.к. держит все контексты в памяти
console.log(sumToIteration(100)); // Медленнее в n раз
console.log(sumToArifmeticProgression(100)); // Самый быстрый!

function factorial(n) {
    return n === 1 ? 1 : factorial(n - 1) * n;
}
console.log(factorial(4));

// вычисление чисел фиббоначи порождает огромное дерево вычислений. Можно оптимизировать
// процесс запоминая и не воспроизводя те же самые вычисления. Например для fib(5) = fib(4) + fib (3) и тд.
// для fib(5) - fib(4) - нужно вызвать 1 раз, fib(3) - 2 раза, fib(2) - 3 раза, fib(1) - 4 раза
function fibbonachiRecursion(n) {
   return n <= 1 ? n : fibbonachiRecursion(n - 1) + fibbonachiRecursion(n - 2);
}
function fibbonachiIteration(n) {
   let fib = [1, 1];
   for (let i = 3; i <= n; i++) {
       fib.push(fib[fib.length - 1] + fib[fib.length - 2]);
   }
   return fib[n - 1];
}
console.log(fibbonachiRecursion(1));
console.log(fibbonachiRecursion(3));
console.log(fibbonachiRecursion(7));
// console.log(fibbonachiRecursion(77)); // будет выполняться очень долго заняв много ресурсов процессора!!!
console.log(fibbonachiIteration(77)); // 5527939700884757
console.log(fibbonachiIteration(7));

let list2 = {
    value: 1,
    next: {
        value: 2,
        next: {
            value: 3,
            next: {
                value: 4,
                next: null
            }
        }
    }
};
function printListRecursion(list) {
    console.log(list.value);
    list.next && printListRecursion(list.next);
}
function printListIteration(list) {
    let tmp = list;
    while (tmp) {
        console.log(tmp.value);
        tmp = tmp.next;
    }
}
printListRecursion(list2);
console.log('-------------------');
printListIteration(list2);
console.log('-------------------');

function revertPrintListRecursion(list) {
    list.next && revertPrintListRecursion(list.next);
    console.log(list.value); // после выполнения всех рекурсий и разбора стека возвращается к
    // функции. И т.к. держит в памяти контексты всех вызовов, выводит значение
}
function revertPrintListIteration(list) {
    let tmp = list;
    let stackValues = [];
    while (tmp) {
        stackValues.push(tmp.value);
        tmp = tmp.next;
    }
    stackValues.reverse().forEach(value => {console.log(value)});
}
revertPrintListRecursion(list2);
console.log('-------------------');
revertPrintListIteration(list2);
