// Прототипное наследование - это возможность языка, которая позволяет расширять объекты,
// переиспользоваться методы и свойства других объектов и создавать объет на основе другого.

// [[Prototype]]
// В JS объекты имеют скрытое свойство [[Prototype]], которое либо равно null, либо ссылается на
// другой объект - прототип.

// object ---[[Prototype]]---> прототип object

// Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт
// его из прототипа. В программировании такой механизм называется «прототипным наследованием».
// Многие интересные возможности языка и техники программирования основываются на нём.

// Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.//
// Одним из них является использование __proto__.

// Animal является прототипом rabbit. Так что если у animal много полезных методов,
// они станут доступны rabbit
let animal = {
    eats: true
};
let rabbit = {
    jumps: true
};
rabbit.__proto__ = animal;
// Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]
// Обратите внимание, что __proto__ — не то же самое, что [[Prototype]]. Это геттер/сеттер для него.

// В современном языке его заменяют функции:
// Object.getPrototypeOf - получает прототип
// Object.setPrototypeOf - устанавливает прототип

// По спецификации __proto__ должен поддерживаться только браузерами, но по факту все среды,
// включая серверную, поддерживают его. Далее мы будем в примерах использовать __proto__,
// так как это самый короткий и интуитивно понятный способ установки и чтения прототипа.

console.log(rabbit.eats); // Если мы ищем свойство в rabbit, а оно отсутствует,
// JavaScript автоматически берёт его из animal.

let longEar = {
    earLength: 10,
    __proto__: rabbit
};
console.log(longEar.earLength);
console.log(longEar.eats);

// Глубина наследования может быть любой, но:
// - Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся
// назначить __proto__ по кругу.
// - Значение __proto__ может быть объектом или null. Другие типы игнорируются.
// - У объекта может быть только один прототип!

// Операции записи/удаления работают напрямую с объектом.
rabbit.eats = 'carrots';
console.log(rabbit.eats); // теперь вызов eats работает непосредственно из объекта rabbit
console.log(animal.eats);

// -------------------------------------------
// Свойства аксессоры, т.к. запись в него обрабатывается функцией сеттером,
// т.е. фактически это вызов функции
let user = {
    name: "John",
    surname: "Smith",
    set fullName(value) {
        [this.name, this.surname] = value.split(" ");
    },
    get fullName() {
        return `${this.name} ${this.surname}`;
    }
};
let admin = {
    __proto__: user,
    isAdmin: true
};
console.log(admin.fullName); // John Smith (*)
// срабатывает сеттер!
admin.fullName = "Alice Cooper"; // (**)
console.log(admin.name); // Alice
console.log(admin.surname); // Cooper
console.log(user.name); // John
console.log(user.surname); // Smith

// Прототипы никак не влияют на this!
// Поэтому в примере выше админ сеттером поменял свое имя, а не юзера

// В результате методы являются общими, а состояние объекта (свойства) — нет.

// Цикл for...in проходит по всем: собственным и унаследованным свойствам!
console.log(Object.keys(longEar)); // показывает только свои ключи!
for(let prop in longEar) console.log(prop); // показывает все унаследованные свойства!

// obj.hasOwnProperty(key); // true если у obj есть собственное свойство с именем key.
console.log(longEar.hasOwnProperty('eats')); // false
console.log(longEar.hasOwnProperty('earLength')); // true
