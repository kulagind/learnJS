// Лексическое окружение (LexicalEnvironment) - скрытый объект у каждой выполняемой функции, блока кода и скрипта
// «Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и
// изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые
// переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение
// объекта должно оставаться таким, как было описано.

// Объект лексического окружения состоит из двух частей:
// 1) Environment Record – объект, в котором как свойства хранятся все локальные переменные
// (а также некоторая другая информация, такая как значение this).
// 2) Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи
// (снаружи от текущих фигурных скобок).

// "Переменная" – это просто свойство специального внутреннего объекта: Environment Record.
// «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

//                          LexicalEnvironment                Outer
//                         (Environment Record)          Внешнее окружение
// начало выполнения -----        <пусто>         --->         null
// let phrase;       -----   phrase: undefined
// phrase = 'Hello'  -----   phrase: 'Hello'
// phrase = 'Bye'    -----   phrase: 'Bye'

// Итого:
// 1) Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся
// блоком/функцией/скриптом.
// 2) Работа с переменными – это на самом деле работа со свойствами этого объекта.

// ------------------------------------------------------------------
// Function Declaration
// В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда,
// когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.
// Для верхнеуровневых функций это означает момент, когда скрипт начинает выполнение.
// Вот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.

//                                              LexicalEnvironment                   Outer
//                                             (Environment Record)             Внешнее окружение
// начало выполнения                    -----     say: function         --->         null
// let phrase = 'Hello';                -----     say: function,
//                                                phrase: 'Hello'
// function say(name) {alert('phrase')} -----     say: function,
//                                                phrase: 'Hello'

let phrase = 'Hello'; //
function say(name) { // функция декларируется и добавляется в лексикал инвайронмент, но "внутрь" никто не заглядывает
    console.log(`${phrase}, ${name}`); // при запуске функции создается новое лексическое окружение для
    // хранение локальных переменных и параметров вызова
    // LexicalEnvironment: {name: john} --outer--> {say: function, phrase: 'Hello'} --outer--> null
    // Во время выполнения есть 2 лексических окружения (внутреннее - для вызываемой функции, и внешнее - глобальное)
    // 1) внутреннее соответствует текущемы выполнению функции say:
    // в нем содержутся аргументы функции и ее переменные, т.е. переменная name = 'John' и ссылка outer на внешнее окружение.
    // 2) внешнее лексическое окружение - глобальное окружение:
    // в нем находятся переменная phrase = 'Hello' и сама функция.
}
say('John');
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом
// окружении, затем во внешнем, затем в следующем и так далее, до глобального.

// Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, для обратной совместимости,
// присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.

// Один вызов = одно лексическое окружение
// Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз,
// когда функция выполняется.
// И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение,
// со своими, специфичными для этого вызова, локальными переменными и параметрами.

// ----------------------------------------------------
// Вложенные функции - функции создается внутри другой функции.

function  sayHiBye(firstName, lastName) {
    // функция-помощник
    function getFullName() {
        return firstName + " " + lastName;
    }

    console.log("Hello, " + getFullName());
    console.log("Bye, " + getFullName());
}


// функция-конструктор возвращает новый объект
function User(name) {
    // методом объекта становится вложенная функция
    this.sayHi = function() {
        console.log(name);
    };
}
let user = new User("John");
user.sayHi(); // у кода метода "sayHi" есть доступ к внешней переменной "name"


function makeCounter() {
    let count = 0;
    return function() {
        return count++; // есть доступ к внешней переменной "count".
        // Порядок поиска count:
        // 1) Локальные переменные вложенной функции…
        // 2) Переменные внешней функции… - есть доступ к внешней переменной "count".
        // 3) И так далее, пока не будут достигнуты глобальные переменные.
    };
}
let counter = makeCounter(); // возвращаем функцию в переменную
let counter2 = makeCounter(); // возвращаем функцию в переменную
// !!!!! Count – локальная переменная функции, мы не можем получить к ней доступ извне.
// !!!!! Для каждого вызова makeCounter() создаётся новое лексическое окружение функции,
// со своим собственным count. Так что, получившиеся функции counter – независимы.

// -------------------------------------------------------
// Окружение в деталях
// !!!!!!!!!!!!!!!!!!!!!Все функции «при рождении» получают скрытое свойство [[Environment]], которое
// ссылается на лексическое окружение места, где они были созданы.!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Функция навсегда запоминает ссылку на лексическое окружение!
// [[Environment]] – скрытое свойство функции, которое содержит эту ссылку.

// Пожалуйста, обратите внимание, как здесь работает управление памятью. Хотя makeCounter()
// закончил выполнение некоторое время назад, его лексическое окружение остаётся в памяти,
// потому что есть вложенная функция с [[Environment]], который ссылается на него.
// В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция,
// которая может его использовать. И только тогда, когда таких не остаётся, окружение уничтожается.

// -------------------------------------------------------
// Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
// То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]]
// и все они могут получить доступ к внешним переменным.

// В Javascript ВСЕ функции являются замыканиями!

// -------------------------------------------------------
// Блоки кода и циклы, IIFE
// - Лексическое окружение существует для любых блоков кода {...}!!!
// - Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого
// блока.

if (true) {
    // Во время выполнения, при попадании в блок if создается новое лексическое окружение
    // с ссылкой на внешнее окружение
    let user2 = 'John';
    console.log(`${phrase}, ${user2}`);
}
// console.log(user2); // Error, т.к. в текущем (глобальном) лексическом окружении нет такой переменной

// Для тела цикла у каждой итерации - создается своё лексическое окружение.

// Мы также можем использовать «простые» блоки кода {...}, чтобы изолировать переменные в
// «локальной области видимости».
// Создано для избежания перегрузки/перезаписи переменных и функций в разных скриптах/местах кода.

{
    // сделать какую-нибудь работу с локальными переменными, которые не должны быть видны снаружи
    let message = "Hello";
    console.log(message); // Hello
}
// console.log(message); // Ошибка: переменная message не определена

// -----------------------------------------------------
// IIFE. В прошлом в JavaScript не было лексического окружения на уровне блоков кода.

// Так что программистам пришлось что-то придумать. И то, что они сделали, называется
// «immediately-invoked function expressions» (аббревиатура IIFE), что означает функцию,
// запускаемую сразу после объявления.

// Это не то, что мы должны использовать сегодня, но, так как вы можете встретить это в старых
// скриптах, полезно понимать принцип работы.
(function() {
    let message = "Hello";
    console.log(message); // Hello
})();
// Скобки вокруг функции – это трюк, который позволяет показать JavaScript, что функция была создана
// в контексте другого выражения, и, таким образом, это функциональное выражение: ей не нужно имя
// и её можно вызвать немедленно.

// Пути создания IIFE:
//
// (function() {
//   alert("Скобки вокруг функции");
// })();
//
// (function() {
//   alert("Скобки вокруг всего");
// }());
//
// !function() {
//   alert("Выражение начинается с побитового оператора NOT");
// }();
//
// +function() {
//   alert("Выражение начинается с унарного плюса");
// }();

// ------------------------------------------
// Сборка мусора.
// Обычно лексическое окружение очищается и удаляется после того, как функция выполнилась.
// …Но, если есть вложенная функция, которая всё ещё доступна после выполнения основной функции,
// то у неё есть свойство [[Environment]], которое ссылается на внешнее лексическое окружение,
// тем самым оставляя его достижимым, «живым»:
function f() {
    let value = 123;
    function g() { console.log(value); }
    return g;
}
let g = f(); // g доступно и продолжает держать внешнее лексическое окружение в памяти

// Объект лексического окружения умирает, когда становится недоступным (как и любой другой объект).
// Другими словами, он существует только до того момента, пока есть хотя бы одна вложенная функция,
// которая ссылается на него.
//
// В следующем коде, после того как g станет недоступным, лексическое окружение функции
// (и, соответственно, value) будет удалено из памяти:
g = null; // ...а теперь память очищается

// ------------------------------------------
// Как мы видели, в теории, пока функция жива, все внешние переменные тоже сохраняются.

// НО! Одним из важных побочных эффектов в V8 (Chrome, Opera) является то, что внешняя переменная
// становится недоступной при отладке.

// Когда код будет поставлен на паузу, напишите в консоли alert(value).
function f2() {
    let value = Math.random();
    function g2() {
        debugger; // в консоли: напишите alert(value); Такой переменной нет!
    }
    return g2;
}
let g2 = f2();
g2();
// В теории, она должна быть доступна, но попала под оптимизацию движка.

// Так например, может случися такое при отладке! Это особенно движка V8
let value = "Сюрприз!";
function f3() {
    let value = "ближайшее значение";
    function g3() {
        debugger; // в консоли: напишите alert(value); Сюрприз!
    }
    return g3;
}
let g3 = f3();
g3();


// ------------------------------------------------
let phrase3 = "Hello";
if (true) {
    let user = "John";
    function sayHi() {
        alert(`${phrase3}, ${user}`);
    }
}
// sayHi(); // ошибка, т.к. функция объявлена внутри блока if и умрет после его выполнения

function sum(a) {
    return function(b) {
        return a + b;
    }
}
console.log(sum(2)(3));

function inBetween(a, b) {
    return function(x) {
        return x >= a && x <= b;
    }
}
function inArray(arr) {
    return function(x) {
        return arr.includes(x);
    }
}
let arr = [1,2,3,4,5,6,7];
console.log(arr.filter(inBetween(3,6)));
console.log(arr.filter(inArray([1, 2, 10])));

function byField(fieldName) {
    // return function (a, b) {
    //     return a[fieldName] > b[fieldName] ? 1 : -1;
    // }
    return (a, b) => a[fieldName] > b[fieldName] ? 1 : -1;
}
let users = [
    { name: "John", age: 20, surname: "Johnson" },
    { name: "Pete", age: 18, surname: "Peterson" },
    { name: "Ann", age: 19, surname: "Hathaway" }
];
users.sort(byField('age'));
console.log(users);

// -----------------------------------
function makeArmy() {
    let shooters = [];
    let i = 0;
    while (i < 10) {
        let shooter = function() { // функция shooter
            alert( i ); // должна выводить порядковый номер
        };
        shooters.push(shooter);
        i++;
    }
    return shooters;
}
let army = makeArmy();
army[0](); // у 0-го стрелка будет номер 10
army[5](); // и у 5-го стрелка тоже будет номер 10
// ... у всех стрелков будет номер 10, вместо 0, 1, 2, 3...

// Т.к. при вызове функции shooter переменная i = 10 и цикл уже закончен в makeArmy()!!! Чтоб это исправить нужно:
// 1) Либо исправить цикл на for (let i...), т.к. будет создаваться новое лексическое окружение в
// каждой итерации с новой i
// 2) Либо объявить новую переменную внутри тела цикла (либо внутри тела подфункции) и делать ей
// присваивание i, чтобы зафиксировать изменяемое значение i в каждом созданном лексическом окружениию.
