// Есть два типа свойств объекта:
// 1) Первый тип это свойства-данные (data properties). Мы уже знаем, как работать с ними.
// Все свойства, которые мы использовали до текущего момента, были свойствами-данными.
// 2) Второй тип свойств мы ещё не рассматривали. Это свойства-аксессоры (accessor properties).
// По своей сути это функции, которые используются для присвоения и получения значения,
// но во внешнем коде они выглядят как обычные свойства объекта.

// getter - свойство только для чтения

// let obj = {
//   get propName() {
//     // геттер, срабатывает при чтении obj.propName
//   },//
//   set propName(value) {
//     // сеттер, срабатывает при записи obj.propName = value
//   }
// };

let user = {
    name: "John",
    surname: "Smith",
    get fullName() { // добавим аксессор чтоб не дублировать свойства
        return `${this.name} ${this.surname}`;
    },
    set fullName(value) { // добавим аксессор чтоб не дублировать свойства
        [this.name, this.surname] = value.split(" ");
    }
};
console.log(user.fullName);
// Мы не вызываем фулНейм, а обращается как обычному свойству, геттер выполнит всю работу за кулисами.

user.fullName = 'test test'; // ошибка (в строгом режиме), у свойства есть только геттер.
// После добавления сеттера метод начал работать!!!
console.log(user); // test test

// Мы получили виртуальное свойство fullName.

// ------------------------------------------------------------------------------
// Дескрипторы свойств аксессоров не имеют value и writable, но имеют get и set
// То есть, дескриптор аксессора может иметь:
// get – функция без аргументов, которая сработает при чтении свойства,
// set – функция, принимающая один аргумент, вызываемая при присвоении свойства,
// enumerable – то же самое, что и для свойств-данных,
// configurable – то же самое, что и для свойств-данных.

// То же самое создание свойства с геттером и сеттером, но через defineProperty
Object.defineProperty(user, 'fullName', {
    get() {
        return `${this.name} ${this.surname}`;
    },
    set(value) {
        [this.name, this.surname] = value.split(" ");
    }
})

// При попытке указать get/set и value в одном дескрипторе вызовет ошибку!!!

// Умные геттеры/сеттеры.
// Например, если мы хотим запретить устанавливать короткое имя для user, мы можем использовать
// сеттер name для проверки, а само значение хранить в отдельном свойстве _name
let user2 = {
    get name() {
        return this._name;
    },
    set name(value) {
        if (value.length < 4) {
            console.log(`Имя '${value}' слишком короткое, должно быть более 4 символов`);
            return;
        }
        this._name = value;
    }
};
user2.name = "Pete";
console.log(user2.name); // Pete
user2.name = "d"; // Имя слишком короткое...

// Таким образом, само имя хранится в _name, доступ к которому производится через геттер и сеттер.
//
// Технически, внешний код всё ещё может получить доступ к имени напрямую с помощью user._name,
// но существует широко известное соглашение о том, что свойства, которые начинаются с символа "_",
// являются внутренними, и к ним не следует обращаться из-за пределов объекта.

// Использование геттеров для совместимости.
function User(name, age) {
    this.name = name;
    this.age = age;
}
let john = new User("John", 25);
console.log( john.age ); // 25
// …Но рано или поздно всё может измениться. Взамен возраста age мы можем решить хранить дату
// рождения birthday, потому что так более точно и удобно:
function User2(name, birthday) {
    this.name = name;
    this.birthday = birthday;
}
let john2 = new User2("John", new Date(1992, 6, 1));
// Что нам делать со старым кодом, который использует свойство age?
// Мы можем попытаться найти все такие места и изменить их, но это отнимает время и может быть
// невыполнимо, если код используется другими людьми. И кроме того, age –
// это отличное свойство для user, верно?

// Давайте его сохраним.
// Добавление геттера для age решит проблему
function User3(name, birthday) {
    this.name = name;
    this.birthday = birthday;

    // возраст рассчитывается из текущей даты и дня рождения
    Object.defineProperty(this, "age", {
        get() {
            let todayYear = new Date().getFullYear();
            return todayYear - this.birthday.getFullYear();
        }
    });
}
let john3 = new User3("John", new Date(1992, 6, 1));
console.log( john3.birthday ); // доступен как день рождения
console.log( john3.age );      // ...так и возраст
