// Когда функция вызывается синтаксисом «метода» – object.method(),
// значением this во время вызова является объект перед точкой.

// this определяется в момент вызова "()" - определение объекта неважно!

let user1 = {
    name: "Джон"
};
let user2 = {
    name: "Ли"
};
function sayHi() { // функция, которая является свойством объекта - называется методом
    console.log('hi' , this.name); // this - текущий объект
}
user1.hi = sayHi;
user2.hi = sayHi;

user1.hi();
// ===
user2['hi']();

// --------------------------------------------
// В строгом режиме 'use strict' без использования объекта
// обращение к this == undefined.
// В нестрогом режим глобально this == window для браузера

// this - является свободным и его значение вычисляется в момент вызовы метода
// зависит от того какой объект стоит перед "точкой" (вызывает) метода

// повышает гибкость и повторное использование функций и методов,
// но с этим же увеличивает количество потенциальных ошибок
// --------------------------------------------

let user = {
    name: 'John',
    hi() {
        console.log('Hi ' + this.name);
    },
    bye() {
        console.log('Bye ' + this.name);
    }
}
user.hi(); // Простой вызов метода работает хорошо
(user.name === 'John' ? user.hi : user.bye)(); // Неверно!
// и вызываем ее уже без контекста!
user.name === 'John' ? user.hi() : user.bye(); // Все снова хорошо!

// Разберемся!!! =>
// obj.method() можно заменить на 2 операции:
// 1) Сначала оператор точка "." возвращает свойство объекта - метод obj.method
// 2) Затем скобки "()" вызывают этот метод (использяется код метода)

// Аналогичная запись:
let hi = user.hi; // метод становится функцией
hi(); // Неверно!!! this потерян

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// Для работы вызовов типа user.hi(), JavaScript использует трюк – точка '.'
// возвращает не саму функцию, а специальное значение «ссылочного типа»,
// называемого Reference Type.

// Значение Reference Type это "триплет" (комбинация из 3х значений):
// (base - сам объект, name - имя свойства, strict - строгий ли режим)
// РЕЗУЛЬТАТОМ ДОСТУПА К МЕТОДУ USER.HI ЯВЛЯЕТСЯ НЕ ФУНКЦИЯ,
// А ЗНАЧЕНИЕ ССЫЛОЧНОГО ТИПА (user, "hi", false)
// Когда скобки "()" применяются к значению ссылочному типу (вызов)
// они получают полную информацию об объекте и его методе
// и могут подставить this.
// За исключением вызова метода "()", любая другая операция
// (подобно операции присваивания = или сравнения через логические операторы,
// например ||) превращает это значение в обычное, которое
// не несёт информации, позволяющей установить this.

// Ссылочный тип – исключительно внутренний, промежуточный, используемый,
// чтобы передать информацию от точки . до вызывающих скобок ().

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// У стрелочных функций нет this.
// его значение берется из внешней "нормальной" функции!
// Они полезны, когда мы не ходим иметь отдельное значение this,
// а хотим взять его из внешнего контекста

let someobj = {
    name: 'Ilya',
    say() {
        let arrowFunc = () => alert(this.name);
        arrowFunc();
    }
};

someobj.say();

// --------------------------------------------------------

function makeUser() {
    return {
        name: "Джон",
        ref: this
    };
}
let task1 = makeUser();
console.log( task1.ref.name ); // Error: Cannot read property 'name' of undefined

function makeUser2() {
    return {
        name: "Джон",
        ref() {
            return this;
        }
    };
}
let task2 = makeUser2();
console.log( task2.ref().name ); // Джон. Т.к. вызывается как метод через "."

let calculator = {
    read(a, b) {
        this.a = +prompt('Enter A:', 0);
        this.b = +prompt('Enter B:', 0);
    },
    sum() {
        return this.a + this.b;
    },
    mul() {
        return this.a * this.b;
    },
}
calculator.read(2, 5);
console.log(calculator.sum());
console.log(calculator.mul());

let ladder = {
    step: 0,
    up() {
        this.step++;
        return this; // вернуть сам объект для дальнейшей работы с ним!!!
    },
    down() {
        this.step--;
        return this; // вернуть сам объект для дальнейшей работы с ним!!!
    },
    showStep: function() { // показывает текущую ступеньку
        alert( this.step );
        return this; // вернуть сам объект для дальнейшей работы с ним!!!
    }
};
ladder.up().up().up().up().down().down().showStep();
