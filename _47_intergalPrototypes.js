// Свойство "prototype" широко используется внутри самого языка JavaScript.
// Все встроенные функции-конструкторы используют его.

// Object.prototype
let obj = {};
console.log(obj.toString()); // [object Object] - но откуда взялся toString?
// Это прототип obj - Object предоставляется все методы.

console.log(obj.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null

// Другие встроенные прототипы
let arr = [1, 2, 3];
// наследует ли от Array.prototype?
console.log( arr.__proto__ === Array.prototype ); // true
// затем наследует ли от Object.prototype?
console.log( arr.__proto__.__proto__ === Object.prototype ); // true
// и null на вершине иерархии
console.log( arr.__proto__.__proto__.__proto__ ); // null


// Примитивы

// Самое сложное происходит со строками, числами и булевыми значениями.
// Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам,
// то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов String,
// Number и Boolean, который предоставит методы и после этого исчезнет.

// Эти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс,
// но спецификация описывает это именно таким образом. Методы этих объектов также находятся в
// прототипах, доступных как String.prototype, Number.prototype и Boolean.prototype.

// Специальные значения null и undefined стоят особняком. У них нет объектов-обёрток,
// так что методы и свойства им недоступны. Также у них нет соответствующих прототипов.


// Изменение встроенных прототипов
// Встроенные прототипы можно изменять
String.prototype.show = function () {
    alert(this);
}
"BOOOM!".show();
// Это плохая идея! Если будет несколько таких методов они могут переписаться!

// В современном программировании есть только один случай, в котором одобряется
// изменение встроенных прототипов. Это создание полифилов.
// Полифил – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript,
// но ещё не поддерживается текущим движком JavaScript:

if (!String.prototype.repeat) { // Если такого метода нет добавляем его в прототип
    String.prototype.repeat = function(n) {
        // повторить строку n раз
        // на самом деле код должен быть немного более сложным
        // (полный алгоритм можно найти в спецификации)
        // но даже неполный полифил зачастую достаточно хорош для использования
        return new Array(n + 1).join(this);
    };
}


// Заимствование прототипов
// Например, если мы создаём объект, похожий на массив (псевдомассив), мы можем скопировать
// некоторые методы из Array в этот объект:
let obj2 = {
    0: "Hello",
    1: "world!",
    length: 2,
};
obj2.join = Array.prototype.join;
console.log( obj2.join(',') ); // Hello,world!
// Это работает, потому что для внутреннего алгоритма встроенного метода join важны только
// корректность индексов и свойство length, он не проверяет, является ли объект на самом деле
// массивом. И многие встроенные методы работают так же.

// Заимствование методов – гибкий способ, позволяющий смешивать функциональность разных объектов по необходимости.

// ----------------------------------------------------------------------------
Function.prototype.defer = function (ms) {
    setTimeout(this, ms);
}
Function.prototype.defer2 = function (ms) {
    let f = this;
    return function(...args) {
        setTimeout(() => f.apply(this, args), ms);
    }
}
function f() {
    console.log('Hello');
}
function f2(a, b) {
    console.log(a + b);
}
console.log(f.defer(2000));
console.log(f2.defer2(2000)(1, 3));
