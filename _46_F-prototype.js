// Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора new F().

// Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]]
// для нового объекта.

// JavaScript использовал прототипное наследование с момента своего появления.
// Это одна из основных особенностей языка.
// Но раньше, в старые времена, прямого доступа к прототипу объекта не было.
// Надёжно работало только свойство "prototype" функции-конструктора, описанное в этой главе.
// Поэтому оно используется во многих скриптах.

let animal = {
    eats: true
};
function Rabbit(name) {
    this.name = name;
}
// Из за передачи всего прототипа мы заменили конструктор!!!
// Rabbit.prototype.eats = true; - перезаписать нужные свойства из прототипа.
Rabbit.prototype = animal; // Установка Rabbit.prototype = animal буквально говорит интерпретатору
// следующее: "При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".
let whiteRabbit = new Rabbit('White Rabbit');  // rabbit.__proto__ == animal
console.log(whiteRabbit.eats); // true

// F.prototype используется только в момент вызова new F()
// F.prototype используется только при вызове new F() и присваивается в качестве свойства
// [[Prototype]] нового объекта. После этого F.prototype и новый объект ничего не связывает.
// Следует понимать это как «единоразовый подарок» объекту.//
// После создания F.prototype может измениться, и новые объекты, созданные с помощью new F(),
// будут иметь другой объект в качестве [[Prototype]], но уже существующие объекты сохранят старый.


// F.prototype по умолчанию
// По умолчанию "prototype" – объект с единственным свойством constructor,
// которое ссылается на функцию-конструктор.

function Rabbit2() {
    this.jumps = true
}
/* прототип по умолчанию
Rabbit.prototype = { constructor: Rabbit };
*/
let someRabbit = new Rabbit2();
console.log(Rabbit2.prototype.constructor == Rabbit2); // true
console.log(whiteRabbit.constructor == Rabbit); // false, т.к. мы унаследовались от animal!!!
// Соответственно, если мы ничего не меняем, то свойство constructor будет
// доступно всем кроликам через [[Prototype]]

// Можно создавать новый объект через свойство-конструктор старого, если оно стоит "по умолчанию"
let blackRabbit = new someRabbit.constructor("Black Rabbit");
console.log(blackRabbit.jumps); // true
let blackRabbit2 = new whiteRabbit.constructor("Black Rabbit 2");
console.log(blackRabbit2.eats); // undefined - т.к. унаследовались от animal!
// Это удобно, когда у нас есть объект, но мы не знаем, какой конструктор использовался для его создания

// ----------------------------------------
// Но, пожалуй, самое важное о свойстве "constructor" это то, что…
// …JavaScript сам по себе не гарантирует правильное значение свойства "constructor".

// Если мы заменим прототип по умолчанию на другой объект, то свойства "constructor" в нём не будет.

// !!!Чтобы сохранить верное свойство "constructor", мы должны добавлять/удалять/изменять свойства
// у прототипа по умолчанию вместо того, чтобы перезаписывать его целиком!!!
Rabbit2.prototype.eats = true;

// Лучше заново создать свойство конструктор!!! Вернуть значение по умолчанию!!!
Rabbit.prototype.constructor = Rabbit;

// Свойство "prototype" является особым, только когда оно назначено функции-конструктору,
// которая вызывается оператором new.
// В обычных объектах prototype не является чем-то особенным:
let user = {
    name: "John",
    prototype: "Bla-bla" // никакой магии нет - обычное свойство
};
