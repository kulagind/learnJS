// setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
// setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

// Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют
// внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех
// браузерах и Node.js.

// let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
// func|code - Функция или строка кода для выполнения. Обычно это функция.
// По историческим причинам можно передать и строку кода, но это не рекомендуется.
// delay - Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
// arg1, arg2… - Аргументы, передаваемые в функцию (не поддерживается в IE9-)

function sayHi(phrase, who) {
    console.log(`${phrase}, ${who}`);
}
setTimeout(sayHi, 1000, 'Hello', 'John');

// Если первый аргумент - строка, то она преобразуется в функцию. Но это не рекомендуется!
setTimeout('console.log("Works only with string")', 1500);

// setTimeout возвращает идентификатора таймера, который можно использовать для дальнейшей отмены таймера
let timerId = setTimeout('console.log("With timer id")', 1000);
console.log('timerId:', timerId);
clearTimeout(timerId);


// setInterval. Следующий отсчет интервала начинает идти с момента окончания предыдущего отсчета
// Реальная задержка между вызовами func с помощью setInterval меньше, чем указано в коде!
// let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
let timerId2 = setInterval('console.log("Interval 500 with timer id")', 500);
setTimeout(() => {clearTimeout(timerId2); console.log('Interval was stopped')}, 2000);


// Для регулярных запусков можно использовать setInterval либо рекурсивный setTimeout
let timerId3 = setTimeout(function tick() {
    console.log('tick');
    timerId3 = setTimeout(tick, 2000); // (*)
}, 2000);
// Рекурсивный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.
// Так же setTimeout начинает отсчет задержки только после выполнения кода функции (при рекурсии);
// Т.е. setTimeout - гарантирует выбранную задержку, тогда как в setInterval если код выплняется долго,
// то задержки может не быть, т.к. она начинается вместе с началом выполнения кода

// Функция ссылается на внешнее лексическое окружение, поэтому пока она существует, внешние переменные
// существуют тоже. Они могут занимать больше памяти, чем сама функция. Поэтому, если регулярный вызов
// функции больше не нужен, то лучше отменить его, даже если функция очень маленькая.


// Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func).
// Это планирует вызов func настолько быстро, насколько это возможно. Но планировщик будет
// вызывать функцию только после завершения выполнения текущего кода.

setTimeout(() => console.log("Мир")); // сначала Привет, затем Мир
console.log("Привет");
// Первая строка помещает вызов в «календарь» через 0 мс. Но планировщик проверит «календарь»
// только после того, как текущий код завершится.


// В стандарте HTML5 говорится: «после пяти вложенных таймеров интервал должен составлять
// не менее четырёх миллисекунд.». (Даже если будет стоять 0мс, интервал составит >4мс на 5
// и последующие вложенные таймеры)

// ---------------------------------------------------------------
function printNumbersInterval(from, to) {
    let number = from;
    let timer = setInterval(() => {console.log(number); number === to ? clearInterval(timer) : number++}, 1000);
}
function printNumbersTimeout(from, to) {
    let number = from;
    let timer2 = setTimeout(function func() {
        console.log(number);
        if (number !== to) {
            number++;
            timer2 = setTimeout(func, 1000);
        }
    }, 1000)

}
printNumbersTimeout(1,10);
// Заметим, что в обоих решениях есть начальная задержка перед первым выводом. Она составляет одну секунду
// (1000мс). Если мы хотим, чтобы функция запускалась сразу же, то надо добавить такой запуск вручную на
// отдельной строке
